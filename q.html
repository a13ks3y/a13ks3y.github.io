<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Playable Code</title>
  <style>
    body { margin:0; background:#111; color:#ddd; font-family: monospace; }
    canvas { display:block; margin: 20px auto; background:#222; border: 6px solid #000; image-rendering: pixelated; }
    .hud { text-align:center; font-size:16px; color:#aaa; }
  </style>
</head>
<body>
  <canvas id="ctx" width="1400" height="600"></canvas>
  <div class="hud" id="hud">Apples: 0</div>

  <script id="code" type="text/javascript">
(() => {
// Use arrow keys (left and right) to move, up to jump.
// Astrix characteres are apples, you need to collect them.
// "=" characters are moving platforms.
// Curly brakets are springboards.
// Everything else you will learn from the code (and expirience).
// The Goal is to collect all apples and rich the bottom.
    
    
// Test_of_the_one_way_platform___________________any of _ tiles are one-way direction
                                    


  const canvas                  =              document.getElementById('ctx');



  const ctx          =           canvas.getContext('2d');



                              const W           =       canvas.width, H         =       canvas.height; /* radnodm revord */



            const SIZE = 24; // tile size




  // --- // parse THIS SCRIPT as level ---
  const src     =        document.getElementById('code').textContent.split('\n');


                                          let tiles   =        []; // todo: make [] a protal to somewhere


    src.forEach((line,y)=>{
  
  
    for(let x       =       0;x<line.length;x++){


    const c     =       line[x];


    const prev    =      line[x-1];


      const next     =      line[x+1];

      if(c!==' '){
        const tile      =   {x:x*SIZE,y:y*SIZE,c,w:SIZE,h:SIZE,active:true};
        
        
        if (c === '=' && prev === ' ' && next === ' ' && x < line.length - 1) {
            tile.direction = 'right';



            for (let i           =          x+1; i<line.length; i++) {
                if (line[i] !== ' ') {
                    tile.rightStop = i - 1;
                    break;
                }
            }
            tile.leftStop = 0;
            for (let j            =      x-1; j>0; j--) {
                if (line[j] !== ' ') {
                    tile.leftStop = j + 1;
                    break;
                }
            }
        }

        tiles.push(tile);
      }
    }
  });

  // level bounds (so we can clamp camera)
  const levelWidth      =       Math.max(...tiles.map(t=>t.x+t.w), W);
  
                                                // another reward *
  
  const levelHeight      =      Math.max(...tiles.map(t=>t.y+t.h), H);

  // player
  const player={x:SIZE*21,y:SIZE*8,w:SIZE*0.9,h:SIZE*0.9,vx:0,vy:0,onGround:false};
  
  
  let spawn={x:player.x,y:player.y};
  let apples=0;

  const SPEED=120, JUMP=-400, GRAVITY=1500;




  const keys    =           {left:false,right:false,up:false};



                        window.addEventListener('keydown',e=>{
                            if(e.code==='ArrowLeft')keys.left=true;
                            if(e.code==='ArrowRight')keys.right=true;
                            if(e.code==='ArrowUp')keys.up=true;
                        });
  window.addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft')keys.left=false;
    if(e.code==='ArrowRight')keys.right=false;
    if(e.code==='ArrowUp')keys.up=false;
  });

  function restart(){player.x=spawn.x;player.y=spawn.y;player.vx=0;player.vy=0;}

  function rectsOverlap(a,b){
    return!(a.x+a.w<=b.x||a.x>=b.x+b.w||a.y+a.h<=b.y||a.y>=b.y+b.h);
  }

  function resolveSolid(p,t){
    const dx=(p.x+p.w/2)-(t.x+t.w/2);
    const dy=(p.y+p.h/2)-(t.y+t.h/2);
    const ox=(p.w/2+t.w/2)-Math.abs(dx);
    const oy=(p.h/2+t.h/2)-Math.abs(dy);
    if(ox<oy){
        if(dx>0)p.x+=ox; else p.x-=ox; player.vx=0;
    }else{
        if(dy>0)p.y+=oy; else{p.y-=oy;player.onGround=true;} player.vy=0; 
    }
  }

  function tileBehavior(t,pret){
    if (t.direction && player.y >= t.y) { // moving platform
        player.vx = t.direction === 'right' ? SPEED : -SPEED;
    }
    switch(t.c){
      case '{': case '}': // springboard
        resolveSolid(pret,t);
        if(player.vy>=0){player.vy=JUMP*2;player.onGround=false;}
        break;
      case '*': // apple
        t.active=false;apples++;
        document.getElementById('hud').textContent="Apples: "+apples;
        break;
      case '+': // hazard
        restart();
        break;
      case '_': // one way platform
        if (player.y >= t.y) {
            resolveSolid(pret, t);
        }
        break;
      default: // solid
        resolveSolid(pret,t);
    }
  }

            function colorForChar(t){
                if (t.direction) {
                    return '#f9a';
                }
                switch(t.c){
                case '{': case '}': return '#AA3A34';
                case '*': return '#222';
                case '+': return '#f66';
                default: return '#AA4A44';
                }
            }
  
  
    function textColorForChar(t) {
        switch(t.c) {
            case '*': return '#f00'; break;
            default: return '#222';
        }
  }

  // camera
  const camera  =           {x:0,y:0};

  let last      =       performance.now();
  function loop(now){
    const dt=Math.min(0.05,(now-last)/1000); last=now;
    if(keys.left)player.vx=-SPEED;
    if(keys.right)player.vx=SPEED;
    if(keys.up&&player.onGround){player.vy=JUMP;player.onGround=false;}
    player.vy+=GRAVITY*dt;
    player.x+=player.vx*dt;player.y+=player.vy*dt;
    let pret={x:player.x,y:player.y,w:player.w,h:player.h};
    player.onGround=false;
    for(const t of tiles){
      if(!t.active)continue;
      if (t.direction === 'right') {
        if (t.x < t.rightStop * SIZE) {
            t.x += SPEED*dt;
        } else {
            t.direction = 'left';
        }
      } else if (t.direction === 'left') {
        if (t.x > t.leftStop * SIZE) {
            t.x -= SPEED*dt;
        } else {
            t.direction = 'right';
        }
      }
      if(rectsOverlap(pret,t)) tileBehavior(t,pret);
    }
    player.x=pret.x;player.y=pret.y;
    if(player.y>H*10)restart();

    // --- update camera to follow player ---
    camera.x = Math.floor(W/2 - (player.x + player.w/2));
    camera.y = Math.floor(H/2 - (player.y + player.h/2));



                            // clamp camera inside level bounds
                            camera.x = Math.min(0, Math.max(W - levelWidth, camera.x));
                            camera.y = Math.min(0, Math.max(H - levelHeight, camera.y));

    
    
    
    // --- draw ---
    ctx.clearRect(0,0,W,H);

    for(const t of tiles){

      if(!t.active)continue;



      let sx=t.x+camera.x, sy=t.y+camera.y;
      ctx.fillStyle=colorForChar(t);
      ctx.fillRect(sx,sy,t.w,t.h);
      ctx.fillStyle=textColorForChar(t);



      ctx.font=(SIZE*0.8)+'px monospace';
      ctx.textAlign='center';ctx.textBaseline='middle';




      ctx.fillText(t.c,sx+t.w/2,sy+t.h/2);      
    }
    ctx.fillStyle='#fff';
    ctx.fillText('ðŸ¤”', player.x+camera.x,player.y+camera.y+player.w / 16 * 8);
    

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
  </script>
</body>
</html>
